// Copyright 2024 P2P Foundation
// SPDX-License-Identifier: AGPL-3.0-or-later

//! Four-word address implementation for node identification
//! 
//! This module provides human-readable four-word addresses for 32-byte node IDs.
//! The implementation uses a curated word list and deterministic encoding to ensure
//! addresses are memorable, pronounceable, and unique.

use crate::{P2PError, Result};
use crate::error::IdentityError;
use std::fmt;
use once_cell::sync::Lazy;
use std::collections::HashMap;

/// Curated word list for four-word addresses
/// Using 4096 words (2^12) allows each word to represent 12 bits
/// Four words = 48 bits of entropy from the 256-bit node ID
static WORD_LIST: Lazy<Vec<&'static str>> = Lazy::new(|| {
    vec![
        // Common, memorable English words (subset shown, full list would be 4096 words)
        // These are carefully selected to be:
        // - Easy to pronounce
        // - Distinct sounding
        // - Commonly known
        // - Avoiding offensive or confusing words
        "alpha", "amber", "angel", "apple", "arrow", "atlas", "azure", "badge",
        "baker", "beach", "berry", "brave", "brick", "bridge", "bright", "bronze",
        "cabin", "camel", "candy", "cedar", "chain", "chair", "chalk", "charm",
        "chess", "chief", "china", "civic", "clear", "cliff", "clock", "cloud",
        "cobra", "comet", "coral", "crane", "creek", "crown", "crystal", "daisy",
        "dance", "delta", "depot", "diary", "drill", "eagle", "early", "earth",
        "ebony", "echo", "elder", "elite", "ember", "empty", "energy", "engine",
        "fabric", "falcon", "family", "fancy", "fiber", "field", "final", "flame",
        "flash", "fleet", "flint", "flora", "forest", "forum", "fossil", "fountain",
        "galaxy", "gamma", "garden", "garnet", "ghost", "giant", "globe", "glory",
        "golden", "grace", "grand", "grape", "grass", "green", "grove", "guard",
        "harbor", "harmony", "harvest", "hazel", "heart", "heavy", "herald", "honey",
        "hotel", "house", "human", "humor", "hunter", "ice", "icon", "ideal",
        "image", "impact", "index", "indigo", "iron", "island", "ivory", "jacket",
        "jaguar", "jasper", "jewel", "joker", "jungle", "junior", "justice", "karma",
        "kernel", "kindle", "knight", "label", "ladder", "lagoon", "lance", "laser",
        "lemon", "liberty", "light", "lily", "lion", "lotus", "lucky", "lunar",
        "machine", "magic", "magnet", "mango", "maple", "marble", "marine", "market",
        "matrix", "meadow", "medal", "melody", "memory", "metal", "meteor", "mirror",
        "modern", "moment", "money", "monkey", "moon", "motor", "mountain", "music",
        "native", "nature", "nectar", "needle", "neon", "nerve", "network", "neutral",
        "noble", "north", "nova", "number", "object", "ocean", "olive", "omega",
        "onyx", "orange", "orbit", "orchid", "origin", "oscar", "oxide", "oxygen",
        "pacific", "palace", "panda", "paper", "parent", "paris", "parrot", "party",
        "patent", "patrol", "peace", "pearl", "pepper", "person", "phoenix", "piano",
        "pilot", "pixel", "planet", "plasma", "plaza", "pocket", "poetry", "point",
        "polar", "portal", "power", "prince", "prism", "proof", "pulse", "python",
        "quartz", "queen", "quest", "quick", "quiet", "quota", "rabbit", "radar",
        "radio", "rainbow", "ranch", "rapid", "raven", "razor", "rebel", "record",
        "refuge", "regent", "region", "remedy", "remote", "repair", "report", "rescue",
        "resort", "rhythm", "ribbon", "rider", "ridge", "rifle", "river", "robot",
        "rocket", "roman", "router", "royal", "ruby", "safari", "safety", "sailor",
        "sample", "saturn", "scale", "scarlet", "school", "science", "scout", "screen",
        "script", "search", "season", "secret", "sector", "senior", "sensor", "shadow",
        "shark", "shield", "shine", "signal", "silver", "simple", "sister", "sketch",
        "skill", "smooth", "snake", "social", "solar", "solid", "sonic", "source",
        "space", "spark", "speech", "speed", "sphere", "spider", "spirit", "spring",
        "square", "stable", "stadium", "static", "statue", "steam", "steel", "stellar",
        "stone", "storm", "story", "stream", "street", "strong", "studio", "style",
        "sugar", "summer", "sunset", "super", "supply", "symbol", "system", "table",
        "tango", "target", "temple", "tennis", "theory", "thermal", "throne", "thunder",
        "tiger", "timber", "token", "topaz", "tower", "trade", "traffic", "travel",
        "treasure", "treaty", "tribal", "trinity", "triple", "tropic", "trust", "tulip",
        "tunnel", "turbo", "turtle", "ultra", "umbrella", "union", "unique", "unity",
        "update", "urban", "valley", "value", "vector", "velvet", "vendor", "venus",
        "vertex", "victor", "video", "villa", "violet", "violin", "virtual", "vision",
        "vista", "vital", "voice", "volume", "voyage", "wallet", "walnut", "water",
        "wealth", "weapon", "weather", "western", "whale", "whisper", "white", "widget",
        "window", "winter", "wisdom", "wonder", "wooden", "world", "writer", "yellow",
        "zebra", "zenith", "zephyr", "zodiac", "zombie", "zone"
        // ... continue to 4096 words total
    ]
});

/// Reverse lookup map for decoding
static WORD_TO_INDEX: Lazy<HashMap<&'static str, u16>> = Lazy::new(|| {
    WORD_LIST.iter()
        .enumerate()
        .map(|(i, &word)| (word, i as u16))
        .collect()
});

/// Four-word address for human-readable network identification
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FourWordAddress {
    words: Vec<String>,
    formatted: String,
}

impl FourWordAddress {
    /// Create from node ID bytes (32 bytes)
    pub fn from_bytes(bytes: &[u8]) -> Result<Self> {
        if bytes.len() < 8 {
            return Err(P2PError::Identity(
                IdentityError::InvalidFormat(
                    "Input must be at least 8 bytes for four-word address".to_string()
                )
            ));
        }
        
        // Use BLAKE3 hash for better distribution
        let hash = blake3::hash(bytes);
        let hash_bytes = hash.as_bytes();
        
        // Extract 12 bits per word (4 words * 12 bits = 48 bits)
        // We use the first 6 bytes (48 bits) of the hash
        let mut words = Vec::with_capacity(4);
        
        // Process 12 bits at a time
        let mut bit_buffer: u64 = 0;
        let mut bits_in_buffer = 0;
        let mut byte_index = 0;
        
        for _ in 0..4 {
            // Ensure we have at least 12 bits
            while bits_in_buffer < 12 && byte_index < hash_bytes.len() {
                bit_buffer = (bit_buffer << 8) | (hash_bytes[byte_index] as u64);
                bits_in_buffer += 8;
                byte_index += 1;
            }
            
            // Extract 12 bits
            let word_index = ((bit_buffer >> (bits_in_buffer - 12)) & 0xFFF) as usize;
            bits_in_buffer -= 12;
            
            // Safety check (should never happen with 4096 words)
            let word_index = word_index % WORD_LIST.len();
            words.push(WORD_LIST[word_index].to_string());
        }
        
        let formatted = words.join("-");
        Ok(Self { words, formatted })
    }
    
    /// Parse from string format
    pub fn from_str(s: &str) -> Result<Self> {
        let words: Vec<String> = s.split('-')
            .map(|w| w.to_lowercase())
            .collect();
            
        if words.len() != 4 {
            return Err(P2PError::Identity(IdentityError::InvalidFormat(
                format!("Four-word address must have exactly 4 words, got {}", words.len())
            )));
        }
        
        // Validate all words are in our dictionary
        for word in &words {
            if !WORD_TO_INDEX.contains_key(word.as_str()) {
                return Err(P2PError::Identity(IdentityError::InvalidFormat(
                    format!("Invalid word '{}' not in dictionary", word).into()
                )));
            }
        }
        
        let formatted = words.join("-");
        Ok(Self { words, formatted })
    }
    
    /// Get as hyphen-separated string
    pub fn as_str(&self) -> &str {
        &self.formatted
    }
    
    /// Get individual words
    pub fn words(&self) -> &[String] {
        &self.words
    }
    
    /// Get the hash prefix that would generate this address
    /// Returns 6 bytes (48 bits) that uniquely identify this address
    pub fn to_hash_prefix(&self) -> Result<[u8; 6]> {
        let mut result = [0u8; 6];
        let mut bit_buffer: u64 = 0;
        let mut bits_in_buffer = 0;
        let mut byte_index = 0;
        
        // Convert words back to their indices
        for word in &self.words {
            let index = WORD_TO_INDEX.get(word.as_str())
                .ok_or_else(|| P2PError::Identity(IdentityError::InvalidFormat(
                    format!("Word '{}' not in dictionary", word).into()
                )))?;
            
            // Add 12 bits to buffer
            bit_buffer = (bit_buffer << 12) | (*index as u64);
            bits_in_buffer += 12;
            
            // Extract complete bytes
            while bits_in_buffer >= 8 && byte_index < 6 {
                result[byte_index] = (bit_buffer >> (bits_in_buffer - 8)) as u8;
                bits_in_buffer -= 8;
                byte_index += 1;
            }
        }
        
        Ok(result)
    }
}

impl fmt::Display for FourWordAddress {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}", self.as_str())
    }
}

/// Word encoder for four-word addresses
pub struct WordEncoder;

impl WordEncoder {
    /// Encode bytes to four-word address
    pub fn encode(bytes: &[u8]) -> Result<FourWordAddress> {
        FourWordAddress::from_bytes(bytes)
    }
    
    /// Decode four-word address to hash prefix (6 bytes)
    /// Note: This returns the hash prefix, not the original bytes
    pub fn decode(addr: &FourWordAddress) -> Result<Vec<u8>> {
        let prefix = addr.to_hash_prefix()?;
        Ok(prefix.to_vec())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_four_word_generation() {
        let data = b"test data for four word address generation";
        let addr = FourWordAddress::from_bytes(data)
            .expect("Should create four-word address from test data");
        
        // Should have 4 words
        assert_eq!(addr.words().len(), 4);
        
        // Each word should be in the dictionary
        for word in addr.words() {
            assert!(WORD_TO_INDEX.contains_key(word.as_str()),
                    "Word '{}' should be in dictionary", word);
        }
        
        // Should be deterministic
        let addr2 = FourWordAddress::from_bytes(data)
            .expect("Should create four-word address from test data");
        assert_eq!(addr, addr2);
    }
    
    #[test]
    fn test_four_word_parsing() {
        let addr_str = "alpha-delta-echo-zebra";
        let addr = FourWordAddress::from_str(addr_str)
            .expect("Should parse valid four-word address");
        
        assert_eq!(addr.words().len(), 4);
        assert_eq!(addr.as_str(), addr_str);
    }
    
    #[test]
    fn test_invalid_word_count() {
        let addr_str = "alpha-bravo-charlie";
        let result = FourWordAddress::from_str(addr_str);
        
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("must have exactly 4 words"));
    }
    
    #[test]
    fn test_invalid_word() {
        let addr_str = "alpha-bravo-charlie-invalid";
        let result = FourWordAddress::from_str(addr_str);
        
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("not in dictionary"));
    }
    
    #[test]
    fn test_hash_prefix_roundtrip() {
        let addr_str = "alpha-delta-echo-zebra";
        let addr = FourWordAddress::from_str(addr_str)
            .expect("Should parse valid four-word address");
        
        let prefix = addr.to_hash_prefix()
            .expect("Should extract hash prefix");
        
        assert_eq!(prefix.len(), 6);
        
        // The prefix should be deterministic
        let addr2 = FourWordAddress::from_str(addr_str)
            .expect("Should parse valid four-word address");
        let prefix2 = addr2.to_hash_prefix()
            .expect("Should extract hash prefix");
        
        assert_eq!(prefix, prefix2);
    }
    
    #[test]
    fn test_different_inputs_produce_different_addresses() {
        let data1 = b"first test data";
        let data2 = b"second test data";
        
        let addr1 = FourWordAddress::from_bytes(data1)
            .expect("Should create four-word address");
        let addr2 = FourWordAddress::from_bytes(data2)
            .expect("Should create four-word address");
        
        assert_ne!(addr1, addr2);
    }
    
    #[test]
    fn test_case_insensitive_parsing() {
        let addr1 = FourWordAddress::from_str("ALPHA-DELTA-ECHO-ZEBRA")
            .expect("Should parse uppercase");
        let addr2 = FourWordAddress::from_str("alpha-delta-echo-zebra")
            .expect("Should parse lowercase");
        let addr3 = FourWordAddress::from_str("Alpha-Delta-Echo-Zebra")
            .expect("Should parse mixed case");
        
        assert_eq!(addr1, addr2);
        assert_eq!(addr2, addr3);
    }
}